{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#_1","title":"Home","text":"Lesson Overview 1. Setting up Git Configuring Git for use 2. Creating a repository Creating a local git repository 3. Tracking Changes Adding and commiting files 4. Exploring History Comparing various versions of tracked files 5. Ignoring Things Excluding specific files and directories from version control 6. Remotes in Github Pushing and pulling from a remote repository <p>Attribution Notice</p> <ul> <li>This workshop material is heavily inspired by :<ol> <li>Software Carpentry Introduction to Version Control with Git and</li> <li>Happy Git with R</li> </ol> </li> </ul> <p>Setup</p> <ul> <li> <p>If possible, we do recommend using the Remote option over Local  ( Especially for Windows hosts). This will eliminate  the need to install any additional applications</p> </li> <li> <p>Remote option will require an existing NeSI Account</p> </li> </ul>"},{"location":"#remote","title":"Remote","text":"Log into NeSI Mahuika Jupyter Service <ol> <li>Follow https://jupyter.nesi.org.nz/hub/login</li> <li><p>Enter NeSI username, HPC password and 6 digit second factor token</p></li> <li><p>Choose server options as below &gt;&gt;make sure to choose the correct project code <code>nesi02659</code>, number of CPUs <code>CPUs=2</code>, memory <code>4 GB</code> prior to pressing   button. <p></p>"},{"location":"#local","title":"Local","text":"Local host setup - Windows, MacOS &amp; Linux Windows HostsMacOSLinux <ul> <li>Git for Windows from https://git-scm.com/download/win</li> </ul> <ul> <li>Native terminal client is sufficient.</li> <li>It might not comes with <code>wget</code> download data via command line (can be installed with <code>$ brew install wget</code>)</li> <li>However, it is not required as we provide a direct link to download data in .zip format</li> </ul> <ul> <li>Native terminal client is sufficient.</li> </ul>"},{"location":"1_overview/","title":"Overview","text":"<p>Overall objective of the workshop</p> <ul> <li>Introduce the benefits of using version control software</li> <li>Understand how to use git for versioning scripts</li> </ul> <p></p> <p>This workshop is heavily derived from Software Carpentry Introduction to Version Control with Git and Happy Git with R</p> <p>We'll start by exploring how version control can be used to keep track of what one person did and when. Even if you aren't collaborating with other people, automated version control is much better than this situation:</p> <p></p> <p>We've all been in this situation before: it seems unnecessary to have multiple nearly-identical versions of the same document. Some word processors let us deal with this a little better, such as Microsoft Word's Track Changes, Google Docs' version history, or LibreOffice's Recording and Displaying Changes.</p> <p>Version control systems start with a base version of the document and then record changes you make each step of the way. You can think of it as a recording of your progress: you can rewind to start at the base document and play back each change you made, eventually arriving at your more recent version.</p> <p></p> <p>Once you think of changes as separate from the document itself, you can then think about \"playing back\" different sets of changes on the base document, ultimately resulting in different versions of that document. For example, two users can make independent sets of changes on the same document.</p> <p></p> <p>Unless multiple users make changes to the same section of the document - a conflict - you can incorporate two sets of changes into the same base document.</p> <p></p> <p>A version control system is a tool that keeps track of these changes for us, effectively creating different versions of our files. It allows us to decide which changes will be made to the next version (each record of these changes is called a commit), and keeps useful metadata about them. The complete history of commits for a particular project and their metadata make up a repository. Repositories can be kept in sync across different computers, facilitating collaboration among different people.</p> <p>The Long History of Version Control Systems</p> <p>Automated version control systems are nothing new. Tools like RCS, CVS, or Subversion have been around since the early 1980s and are used by many large companies. However, many of these are now considered legacy systems (i.e., outdated) due to various limitations in their capabilities. More modern systems, such as Git and Mercurial, are distributed, meaning that they do not need a centralized server to host the repository. These modern systems also include powerful merging tools that make it possible for multiple authors to work on the same files concurrently.</p> <p>Paper Writing</p> <ul> <li> <p>Imagine you drafted an excellent paragraph for a paper you are writing, but later ruin it. How would you retrieve the excellent version of your conclusion? Is it even possible?</p> </li> <li> <p>Imagine you have 5 co-authors. How would you manage the changes and comments they make to your paper? If you use LibreOffice Writer or Microsoft Word, what happens if you accept changes made using the <code>Track Changes</code> option? Do you have a history of those changes?</p> </li> </ul> Solution <ul> <li> <p>Recovering the excellent version is only possible if you created a copy   of the old version of the paper. The danger of losing good versions   often leads to the problematic workflow illustrated in the PhD Comics   cartoon at the top of this page.</p> </li> <li> <p>Collaborative writing with traditional word processors is cumbersome.   Either every collaborator has to work on a document sequentially   (slowing down the process of writing), or you have to send out a   version to all collaborators and manually merge their comments into   your document. The 'track changes' or 'record changes' option can   highlight changes for you and simplifies merging, but as soon as you   accept changes you will lose their history. You will then no longer   know who suggested that change, why it was suggested, or when it was   merged into the rest of the document. Even online word processors like   Google Docs or Microsoft Office Online do not fully resolve these   problems.</p> </li> </ul> <p>Keypoints</p> <ul> <li>Version control is like an unlimited 'undo'.</li> <li>Version control also allows many people to work in parallel.</li> </ul>"},{"location":"2_summary_setup/","title":"Setup","text":"<p>Lesson Objectives</p> <ul> <li>Create a github account</li> <li>Configure <code>git</code> the first time it is used on a computer.</li> <li>Understand the meaning of the <code>--global</code> configuration flag.</li> </ul>"},{"location":"2_summary_setup/#create-a-github-account","title":"Create a Github account","text":"<p>Before we get started with Git we're going to create an account on Github</p> <p>Head over to https://github.com and create a free account if you don't already have one. Once you have an account we can configure Git on your machine.</p>"},{"location":"2_summary_setup/#configuring-git","title":"Configuring Git","text":"<p>When we use Git on a new computer for the first time, we need to configure a few things. Below are a few examples of configurations we will set as we get started with Git:</p> <ul> <li>our name and email address,</li> <li>what our preferred text editor is,</li> <li>and that we want to use these settings globally (i.e. for every project).</li> </ul> <p>On a command line, Git commands are written as <code>git verb options</code>, where <code>verb</code> is what we actually want to do and <code>options</code> is additional optional information which may be needed for the <code>verb</code>. So here are the commands to set up your computer - replacing the values in the &lt;&gt; with your information:</p> <p>code</p> <pre><code>$ git config --global user.name \"&lt;Firstname&gt; &lt;Lastname&gt;\"\n$ git config --global user.email \"&lt;username@email.com&gt;\"\n</code></pre> <p>Please use your own name and email address. This user name and email will be associated with your subsequent Git activity, which means that any changes pushed to GitHub, BitBucket, GitLab or another Git host server after this lesson will include this information.</p> <p>For this lesson, we will be interacting with GitHub and so the email address used should be the same as the one used when setting up your GitHub account. If you are concerned about privacy, please review GitHub's instructions for keeping your email address private.</p> <p>Keeping your email private</p> <p>If you elect to use a private email address with GitHub, then use that same email address for the <code>user.email</code> value, e.g. <code>username@users.noreply.github.com</code> replacing <code>username</code> with your GitHub one.</p> <p>Line Endings</p> <p>As with other keys, when you hit Enter or \u21b5 or on Macs, Return on your keyboard, your computer encodes this input as a character. Different operating systems use different character(s) to represent the end of a line. (You may also hear these referred to as newlines or line breaks.) Because Git uses these characters to compare files, it may cause unexpected issues when editing a file on different machines. Though it is beyond the scope of this lesson, you can read more about this issue in the Pro Git book.</p> <p>You can change the way Git recognizes and encodes line endings using the <code>core.autocrlf</code> command to <code>git config</code>. The following settings are recommended:</p> <p>On macOS and Linux:</p> <p>code</p> <pre><code>$ git config --global core.autocrlf input\n</code></pre> <p>And on Windows:</p> <p>code</p> <pre><code>$ git config --global core.autocrlf true\n</code></pre> <p>It is also worth setting your favorite text editor, following this table:</p> Editor Configuration command Atom <code>$ git config --global core.editor \"atom --wait\"</code> nano <code>$ git config --global core.editor \"nano -w\"</code> BBEdit (Mac, with command line tools) <code>$ git config --global core.editor \"bbedit -w\"</code> Sublime Text (Mac) <code>$ git config --global core.editor \"/Applications/Sublime\\ Text.app/Contents/SharedSupport/bin/subl -n -w\"</code> Sublime Text (Win, 32-bit install) <code>$ git config --global core.editor \"'c:/program files (x86)/sublime text 3/sublime_text.exe' -w\"</code> Sublime Text (Win, 64-bit install) <code>$ git config --global core.editor \"'c:/program files/sublime text 3/sublime_text.exe' -w\"</code> Notepad (Win) <code>$ git config --global core.editor \"c:/Windows/System32/notepad.exe\"</code> Notepad++ (Win, 32-bit install) <code>$ git config --global core.editor \"'c:/program files (x86)/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin\"</code> Notepad++ (Win, 64-bit install) <code>$ git config --global core.editor \"'c:/program files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin\"</code> Kate (Linux) <code>$ git config --global core.editor \"kate\"</code> Gedit (Linux) <code>$ git config --global core.editor \"gedit --wait --new-window\"</code> Scratch (Linux) <code>$ git config --global core.editor \"scratch-text-editor\"</code> Emacs <code>$ git config --global core.editor \"emacs\"</code> Vim <code>$ git config --global core.editor \"vim\"</code> VS Code <code>$ git config --global core.editor \"code --wait\"</code> <p>It is possible to reconfigure the text editor for Git whenever you want to change it.</p> <p>Exiting Vim</p> <p>Note that Vim is the default editor for many programs. If you haven't used Vim before and wish to exit a session without saving your changes, press Esc then type <code>:q!</code> and hit Enter or \u21b5 or on Macs, Return. If you want to save your changes and quit, press Esc then type <code>:wq</code> and hit Enter or \u21b5 or on Macs, Return.</p> <p>Git (2.28+) allows configuration of the name of the branch created when you initialize any new repository. We will use this feature to set it to <code>main</code> so it matches the cloud service we will eventually use.</p> <p>code</p> <pre><code>$ git config --global init.defaultBranch main\n</code></pre> <p>Default Git branch naming</p> <p>Source file changes are associated with a \"branch.\" For new learners in this lesson, it's enough to know that branches exist, and this lesson uses one branch. By default, Git will create a branch called <code>master</code> when you create a new repository with <code>git init</code> (as explained in the next Episode). This term evokes the racist practice of human slavery and the software development community has moved to adopt more inclusive language.</p> <p>In 2020, most Git code hosting services transitioned to using <code>main</code> as the default branch. As an example, any new repository that is opened in GitHub and GitLab default to <code>main</code>. However, Git has not yet made the same change. As a result, local repositories must be manually configured have the same main branch name as most cloud services.</p> <p>For versions of Git prior to 2.28, the change can be made on an individual repository level. The command for this is in the next episode. Note that if this value is unset in your local Git configuration, the <code>init.defaultBranch</code> value defaults to <code>master</code>.</p> <p>The five commands we just ran above only need to be run once: the flag <code>--global</code> tells Git to use the settings for every project, in your user account, on this computer.</p> <p>Let's review those settings and test our <code>core.editor</code> right away:</p> <p>code</p> <pre><code>$ git config --global --edit\n</code></pre> <p>Let's close the file without making any additional changes. Remember, since typos in the config file will cause issues, it's safer to view the configuration with:</p> <p>code</p> <pre><code>$ git config --list\n</code></pre> <p>And if necessary, change your configuration using the same commands to choose another editor or update your email address. This can be done as many times as you want.</p> <p>Proxy</p> <p>In some networks you need to use a proxy. If this is the case, you may also need to tell Git about the proxy:</p> <p>code</p> <pre><code>$ git config --global http.proxy proxy-url\n$ git config --global https.proxy proxy-url\n</code></pre> <p>To disable the proxy, use</p> <p>code</p> <pre><code>$ git config --global --unset http.proxy\n$ git config --global --unset https.proxy\n</code></pre> <p>Git Help and Manual</p> <p>Always remember that if you forget the subcommands or options of a <code>git</code> command, you can access the relevant list of options typing <code>git &lt;command&gt; -h</code> or access the corresponding Git manual by typing <code>git &lt;command&gt; --help</code>, e.g.:</p> <p>code</p> <pre><code>$ git config -h\n$ git config --help\n</code></pre> <p>While viewing the manual, remember the <code>:</code> is a prompt waiting for commands and you can press Q to exit the manual.</p> <p>More generally, you can get the list of available <code>git</code> commands and further resources of the Git manual typing:</p> <p>code</p> <pre><code>$ git help\n</code></pre> <p>Clipboard-list</p> <ul> <li>Use <code>git config</code> with the <code>--global</code> option to configure a user name, email address, editor, and other preferences once per machine.</li> </ul>"},{"location":"3_create_repo/","title":"Creating a Repository","text":"<p>Objectives</p> <ul> <li>Create a local Git repository.</li> <li>Describe the purpose of the <code>.git</code> directory.</li> </ul> <p>Once Git is configured, we can start using it.</p> <p>We're going to use the Genomic Variant Calling workshop as the basis for our repository</p> <p>First, let's navigate into the directory for the lesson <code>~/obss_2023/intro-git</code> and create a new directory <code>vc_project</code> there for our repository to live in:</p> <p>code</p> <pre><code>$ cd ~/obss_2023/intro-git\n$ mkdir vc_project\n$ cd vc_project\n</code></pre> <p>Then we tell Git to make <code>vc_project</code> a repository -- a place where Git can store versions of our files:</p> <p>code</p> <pre><code>$ git init\n</code></pre> <p>It is important to note that <code>git init</code> will create a repository that can include subdirectories and their files---there is no need to create separate repositories nested within the <code>vc_project</code> repository, whether subdirectories are present from the beginning or added later. Also, note that the creation of the <code>vc_project</code> directory and its initialization as a repository are completely separate processes.</p> <p>If we use <code>ls</code> to show the directory's contents, it appears that nothing has changed:</p> <p>code</p> <pre><code>$ ls\n</code></pre> <p>But if we add the <code>-a</code> flag to show everything, we can see that Git has created a hidden directory within <code>vc_project</code> called <code>.git</code>:</p> <p>code</p> <pre><code>$ ls -a\n</code></pre> <p>code</p> <pre><code>.   ..  .git\n</code></pre> <p>Git uses this special subdirectory to store all the information about the project, including the tracked files and sub-directories located within the project's directory. If we ever delete the <code>.git</code> subdirectory, we will lose the project's history.</p> <p>Next, we will change the default branch to be called <code>main</code>. This might be the default branch depending on your settings and version of git. See the setup episode for more information on this change.</p> <p>code</p> <pre><code>$ git checkout -b main\n</code></pre> <p>code</p> <pre><code>Switched to a new branch 'main'\n</code></pre> <p>We can check that everything is set up correctly by asking Git to tell us the status of our project:</p> <p>code</p> <pre><code>$ git status\n</code></pre> <p>code</p> <pre><code>On branch main\n\nNo commits yet\n\nnothing to commit (create/copy files and use \"git add\" to track)\n</code></pre> <p>If you are using a different version of <code>git</code>, the exact wording of the output might be slightly different.</p> <p>Places to Create Git Repositories</p> <p>Along with tracking information about variant calling (the project we have already created), We would also like to track information about ecoli. Lets creates an <code>ecoli</code> project inside our <code>vc_project</code> project with the following sequence of commands:</p> <p>code</p> <pre><code>$ cd ~/obss_2023/intro-git   # return to Desktop directory\n$ cd vc_project     # go into vc_project directory, which is already a Git repository\n$ ls -a          # ensure the .git subdirectory is still present in the vc_project directory\n$ mkdir ecoli    # make a subdirectory vc_project/ecoli\n$ cd ecoli       # go into ecoli subdirectory\n$ git init       # make the ecoli subdirectory a Git repository\n$ ls -a          # ensure the .git subdirectory is present indicating we have created a new Git repository\n</code></pre> <p>Is the <code>git init</code> command, run inside the <code>ecoli</code> subdirectory, required for tracking files stored in the <code>ecoli</code> subdirectory?</p> Solution <p>No. we do not need to make the <code>ecoli</code> subdirectory a Git repository because the <code>vc_project</code> repository can track any files, sub-directories, and subdirectory files under the <code>vc_project</code> directory. Thus, in order to track all information about moons, we only needed to add the <code>ecoli</code> subdirectory to the <code>vc_project</code> directory.</p> <p>Additionally, Git repositories can interfere with each other if they are \"nested\": the outer repository will try to version-control the inner repository. Therefore, it's best to create each new Git repository in a separate directory. To be sure that there is no conflicting repository in the directory, check the output of <code>git status</code>. If it looks like the following, you are good to go to create a new repository as shown above:</p> <p>code</p> <pre><code>$ git status\n</code></pre> <p>code</p> <pre><code>fatal: Not a git repository (or any of the parent directories): .git\n</code></pre> <p>Correcting <code>git init</code> Mistakes</p> <p>A nested repository is redundant and may cause confusion down the road. We would like to remove the nested repository. How can we undo the last <code>git init</code> in the <code>ecoli</code> subdirectory?</p> Solution -- USE WITH CAUTION! <p>Background</p> <p>Removing files from a Git repository needs to be done with caution. But we have not learned yet how to tell Git to track a particular file; we will learn this in the next episode. Files that are not tracked by Git can easily be removed like any other \"ordinary\" files with</p> <p>code</p> <pre><code>$ rm filename\n</code></pre> <p>Similarly a directory can be removed using <code>rm -r dirname</code> or <code>rm -rf dirname</code>. If the files or folder being removed in this fashion are tracked by Git, then their removal becomes another change that we will need to track, as we will see in the next episode.</p> <p>Solution</p> <p>Git keeps all of its files in the <code>.git</code> directory. To recover from this little mistake, we can just remove the <code>.git</code> folder in the ecoli subdirectory by running the following command from inside the <code>vc_project</code> directory:</p> <p>code</p> <pre><code>$ rm -rf ecoli/.git\n</code></pre> <p>But be careful! Running this command in the wrong directory will remove the entire Git history of a project you might want to keep. Therefore, always check your current directory using the command <code>pwd</code>.</p> <p>keypoints</p> <ul> <li><code>git init</code> initializes a repository.</li> <li>Git stores all of its repository data in the <code>.git</code> directory.</li> </ul>"},{"location":"4_tracking_changes/","title":"Tracking Changes","text":"<p>Objectives</p> <ul> <li>Go through the modify-add-commit cycle for one or more files.</li> <li>Explain where information is stored at each stage of that cycle.</li> <li>Distinguish between descriptive and non-descriptive commit messages.</li> </ul> <p>First let's make sure we're still in the right directory. You should be in the <code>vc_project</code> directory.</p> <p>code</p> <pre><code>$ cd ~/obss_2023/intro-git/vc_project\n</code></pre> <p>Let's create a file called <code>README.txt</code> that contains some notes about the variant calling workflow. We'll use <code>nano</code> to edit the file; you can use whatever editor you like. In particular, this does not have to be the <code>core.editor</code> you set globally earlier. But remember, the bash command to create or edit a new file will depend on the editor you choose (it might not be <code>nano</code>). For a refresher on text editors, check out \"Which Editor?\" in The Unix Shell lesson.</p> <p>code</p> <pre><code>$ nano README.txt\n</code></pre> <p>Type the text below into the <code>README.txt</code> file:</p> <p>code</p> <pre><code>Project notes for the variant calling workflow\n</code></pre> <p>Let's first verify that the file was properly created by running the list command (<code>ls</code>):</p> <p>code</p> <pre><code>$ ls\n</code></pre> <pre><code>README.txt\n</code></pre> <p><code>README.txt</code> contains a single line, which we can see by running:</p> <p>code</p> <pre><code>$ cat README.txt\n</code></pre> <pre><code>Project notes for the variant calling workflow\n</code></pre> <p>If we check the status of our project again, Git tells us that it's noticed the new file:</p> <p>code</p> <pre><code>$ git status\n</code></pre> <pre><code>On branch main\n\nNo commits yet\n\nUntracked files:\n(use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    README.txt\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n</code></pre> <p>The \"untracked files\" message means that there's a file in the directory that Git isn't keeping track of. We can tell Git to track a file using <code>git add</code>:</p> <p>code</p> <pre><code>$ git add README.txt\n</code></pre> <p>and then check that the right thing happened:</p> <p>code</p> <pre><code>$ git status\n</code></pre> <pre><code>On branch main\n\nNo commits yet\n\nChanges to be committed:\n(use \"git rm --cached &lt;file&gt;...\" to unstage)\n\n    new file:   README.txt\n</code></pre> <p>Git now knows that it's supposed to keep track of <code>README.txt</code>, but it hasn't recorded these changes as a commit yet. To get it to do that, we need to run one more command:</p> <p>code</p> <pre><code>$ git commit -m \"Start notes project\"\n</code></pre> <pre><code>[main (root-commit) f22b25e] Start notes project\n1 file changed, 1 insertion(+)\ncreate mode 100644 README.txt\n</code></pre> <p>When we run <code>git commit</code>, Git takes everything we have told it to save by using <code>git add</code> and stores a copy permanently inside the special <code>.git</code> directory. This permanent copy is called a commit (or revision) and its short identifier is <code>f22b25e</code>. Your commit may have another identifier.</p> <p>We use the <code>-m</code> flag (for \"message\") to record a short, descriptive, and specific comment that will help us remember later on what we did and why. If we just run <code>git commit</code> without the <code>-m</code> option, Git will launch <code>nano</code> (or whatever other editor we configured as <code>core.editor</code>) so that we can write a longer message.</p> <p>Good commit messages start with a brief (\\&lt;50 characters) statement about the changes made in the commit. Generally, the message should complete the sentence \"If applied, this commit will\" . If you want to go into more detail, add a blank line between the summary line and your additional notes. Use this additional space to explain why you made changes and/or what their impact will be. <p>If we run <code>git status</code> now:</p> <p>code</p> <pre><code>$ git status\n</code></pre> <pre><code>On branch main\nnothing to commit, working tree clean\n</code></pre> <p>it tells us everything is up to date. If we want to know what we've done recently, we can ask Git to show us the project's history using <code>git log</code>:</p> <p>code</p> <pre><code>$ git log\n</code></pre> <pre><code>commit f22b25e3233b4645dabd0d81e651fe074bd8e73b\nAuthor: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;\nDate:   Thu Aug 22 09:51:46 2013 -0400\n\n    Start notes project\n</code></pre> <p><code>git log</code> lists all commits made to a repository in reverse chronological order. The listing for each commit includes the commit's full identifier (which starts with the same characters as the short identifier printed by the <code>git commit</code> command earlier), the commit's author, when it was created, and the log message Git was given when the commit was created.</p> <p>Where Are My Changes?</p> <p>If we run <code>ls</code> at this point, we will still see just one file called <code>README.txt</code>. That's because Git saves information about files' history in the special <code>.git</code> directory mentioned earlier so that our filesystem doesn't become cluttered (and so that we can't accidentally edit or delete an old version).</p> <p>Now suppose Dracula adds more information to the file. (Again, we'll edit with <code>nano</code> and then <code>cat</code> the file to show its contents; you may use a different editor, and don't need to <code>cat</code>.)</p> <p>code</p> <pre><code>$ nano README.txt\n$ cat README.txt\n</code></pre> <pre><code>Project notes for the variant calling workflow\n\n1. Perform QC\n</code></pre> <p>When we run <code>git status</code> now, it tells us that a file it already knows about has been modified:</p> <p>code</p> <pre><code>$ git status\n</code></pre> <pre><code>On branch main\nChanges not staged for commit:\n(use \"git add &lt;file&gt;...\" to update what will be committed)\n(use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n    modified:   README.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n</code></pre> <p>The last line is the key phrase: \"no changes added to commit\". We have changed this file, but we haven't told Git we will want to save those changes (which we do with <code>git add</code>) nor have we saved them (which we do with <code>git commit</code>). So let's do that now. It is good practice to always review our changes before saving them. We do this using <code>git diff</code>. This shows us the differences between the current state of the file and the most recently saved version:</p> <p>code</p> <pre><code>$ git diff\n</code></pre> <pre><code>diff --git a/README.txt b/README.txt\nindex df0654a..315bf3a 100644\n--- a/README.txt\n+++ b/README.txt\n@@ -1 +1,3 @@\nProject notes for the variant calling workflow\n+\n+1. Perform QC\n</code></pre> <p>The output is cryptic because it is actually a series of commands for tools like editors and <code>patch</code> telling them how to reconstruct one file given the other. If we break it down into pieces:</p> <ol> <li>The first line tells us that Git is producing output similar to the Unix <code>diff</code> command    comparing the old and new versions of the file.</li> <li>The second line tells exactly which versions of the file    Git is comparing;    <code>df0654a</code> and <code>315bf3a</code> are unique computer-generated labels for those versions.</li> <li>The third and fourth lines once again show the name of the file being changed.</li> <li>The remaining lines are the most interesting, they show us the actual differences    and the lines on which they occur.    In particular,    the <code>+</code> marker in the first column shows where we added a line.</li> </ol> <p>After reviewing our change, it's time to commit it:</p> <p>code</p> <pre><code>$ git commit -m \"Add first step of workflow\"\n</code></pre> <pre><code>On branch main\nChanges not staged for commit:\n(use \"git add &lt;file&gt;...\" to update what will be committed)\n(use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n    modified:   README.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n</code></pre> <p>Whoops: Git won't commit because we didn't use <code>git add</code> first. Let's fix that:</p> <p>code</p> <pre><code>$ git add README.txt\n$ git commit -m \"Add first step of workflow\"\n</code></pre> <pre><code>[main 34961b1] Add first step of workflow\n1 file changed, 2 insertion(+)\n</code></pre> <p>Git insists that we add files to the set we want to commit before actually committing anything. This allows us to commit our changes in stages and capture changes in logical portions rather than only large batches. For example, suppose we're adding a few citations to relevant research to our thesis. We might want to commit those additions, and the corresponding bibliography entries, but not commit some of our work drafting the conclusion (which we haven't finished yet).</p> <p>To allow for this, Git has a special staging area where it keeps track of things that have been added to the current changeset but not yet committed.</p> <p>Staging Area</p> <p>If you think of Git as taking snapshots of changes over the life of a project, <code>git add</code> specifies what will go in a snapshot (putting things in the staging area), and <code>git commit</code> then actually takes the snapshot, and makes a permanent record of it (as a commit). If you don't have anything staged when you type <code>git commit</code>, Git will prompt you to use <code>git commit -a</code> or <code>git commit --all</code>, which is kind of like gathering everyone to take a group photo! However, it's almost always better to explicitly add things to the staging area, because you might commit changes you forgot you made. (Going back to the group photo simile, you might get an extra with incomplete makeup walking on the stage for the picture because you used <code>-a</code>!) Try to stage things manually, or you might find yourself searching for \"git undo commit\" more than you would like!</p> <p></p> <p>Let's watch as our changes to a file move from our editor to the staging area and into long-term storage. First, we'll add another line to the file:</p> <p>code</p> <pre><code>$ nano READEME.txt\n$ cat README.txt\n</code></pre> <pre><code>Project notes for the variant calling workflow\n\n1. Perform QC\n2. Align reads\n</code></pre> <p>code</p> <pre><code>$ git diff\n</code></pre> <pre><code>diff --git a/README.txt b/README.txt\nindex 315bf3a..b36abfd 100644\n--- a/README.txt\n+++ b/README.txt\n@@ -1,3 +1,4 @@\n Project notes for the variant calling workflow\n\n 1. Perform QC\n+2. Align reads\n</code></pre> <p>So far, so good: we've added one line to the end of the file (shown with a <code>+</code> in the first column). Now let's put that change in the staging area and see what <code>git diff</code> reports:</p> <p>code</p> <pre><code>$ git add README.txt\n$ git diff\n</code></pre> <p>There is no output: as far as Git can tell, there's no difference between what it's been asked to save permanently and what's currently in the directory. However, if we do this:</p> <p>code</p> <pre><code>$ git diff --staged\n</code></pre> <pre><code>diff --git a/README.txt b/README.txt\nindex 315bf3a..b36abfd 100644\n--- a/README.txt\n+++ b/README.txt\n@@ -1,2 +1,3 @@\n Project notes for the variant calling workflow\n\n 1. Perform QC\n+2. Align reads\n</code></pre> <p>it shows us the difference between the last committed change and what's in the staging area. Let's save our changes:</p> <p>code</p> <pre><code>$ git commit -m \"add alignment step\"\n</code></pre> <pre><code>[main 005937f] add alignment step\n1 file changed, 1 insertion(+)\n</code></pre> <p>check our status:</p> <p>code</p> <pre><code>$ git status\n</code></pre> <pre><code>On branch main\nnothing to commit, working tree clean\n</code></pre> <p>and look at the history of what we've done so far:</p> <p>Terminal-2</p> <pre><code>$ git log\n</code></pre> <pre><code>commit 005937fbe2a98fb83f0ade869025dc2636b4dad5 (HEAD -&gt; main)\nAuthor: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;\nDate:   Thu Aug 22 10:14:07 2013 -0400\n\n    add alignment step\n\ncommit 34961b159c27df3b475cfe4415d94a6d1fcd064d\nAuthor: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;\nDate:   Thu Aug 22 10:07:21 2013 -0400\n\n    Add first step of workflow\n\ncommit f22b25e3233b4645dabd0d81e651fe074bd8e73b\nAuthor: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;\nDate:   Thu Aug 22 09:51:46 2013 -0400\n\n    Start notes project\n</code></pre> <p>Word-based diffing</p> <p>Sometimes, e.g. in the case of the text documents a line-wise diff is too coarse. That is where the <code>--color-words</code> option of <code>git diff</code> comes in very useful as it highlights the changed words using colors.</p> <p>Paging the Log</p> <p>When the output of <code>git log</code> is too long to fit in your screen, <code>git</code> uses a program to split it into pages of the size of your screen. When this \"pager\" is called, you will notice that the last line in your screen is a <code>:</code>, instead of your usual prompt.</p> <ul> <li>To get out of the pager, press Q.</li> <li>To move to the next page, press Spacebar.</li> <li>To search for <code>some_word</code> in all pages, press / and type <code>some_word</code>. Navigate through matches pressing N.</li> </ul> <p>Limit Log Size</p> <p>To avoid having <code>git log</code> cover your entire terminal screen, you can limit the number of commits that Git lists by using <code>-N</code>, where <code>N</code> is the number of commits that you want to view. For example, if you only want information from the last commit you can use:</p> <p>code</p> <pre><code>$ git log -1\n</code></pre> <pre><code>commit 005937fbe2a98fb83f0ade869025dc2636b4dad5 (HEAD -&gt; main)\nAuthor: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;\nDate:   Thu Aug 22 10:14:07 2013 -0400\n\nadd alignment step\n</code></pre> <p>You can also reduce the quantity of information using the <code>--oneline</code> option:</p> <p>code</p> <pre><code>$ git log --oneline\n</code></pre> <pre><code>005937f (HEAD -&gt; main) add alignment step\n34961b1 Add first step of workflow\nf22b25e Start notes project\n</code></pre> <p>You can also combine the <code>--oneline</code> option with others. One useful combination adds <code>--graph</code> to display the commit history as a text-based graph and to indicate which commits are associated with the current <code>HEAD</code>, the current branch <code>main</code>, or other Git references:</p> <p>code</p> <pre><code>$ git log --oneline --graph\n</code></pre> <pre><code>* 005937f (HEAD -&gt; main) add alignment step\n* 34961b1 Add first step of workflow\n* f22b25e Start notes project\n</code></pre> <p>Directories</p> <p>Two important facts you should know about directories in Git.</p> <ol> <li>Git does not track directories on their own, only files within them. Try it for yourself:</li> </ol> <p>code</p> <pre><code>$ mkdir scripts\n$ git status\n$ git add scripts\n$ git status\n</code></pre> <p>Note, our newly created empty directory <code>scripts</code> does not appear in the list of untracked files even if we explicitly add it (via <code>git add</code>) to our repository. This is the reason why you will sometimes see <code>.gitkeep</code> files in otherwise empty directories. Unlike <code>.gitignore</code>, these files are not special and their sole purpose is to populate a directory so that Git adds it to the repository. In fact, you can name such files anything you like.</p> <ol> <li>If you create a directory in your Git repository and populate it with files, you can add all files in the directory at once by:</li> </ol> <p>code</p> <pre><code>git add &lt;directory-with-files&gt;\n</code></pre> <p>Try it for yourself:</p> <p>code</p> <pre><code>$ touch scripts/qc.sh scripts/align.sh\n$ git status\n$ git add scripts\n$ git status\n</code></pre> <p>Before moving on, we will commit these changes.</p> <p>code</p> <pre><code>$ git commit -m \"Add some beginnings of scripts\"\n</code></pre> <p>To recap, when we want to add changes to our repository, we first need to add the changed files to the staging area (<code>git add</code>) and then commit the staged changes to the repository (<code>git commit</code>):</p> <p></p> <p>Choosing a Commit Message</p> <p>Which of the following commit messages would be most appropriate for the last commit made to <code>README.txt</code>?</p> <ol> <li>\"Changes\"</li> <li>\"Added line '1. Perform QC' to README.txt\"</li> <li>\"Add first step of workflow\"</li> </ol> Solution <p>Answer 1 is not descriptive enough, and the purpose of the commit is unclear; and answer 2 is redundant to using \"git diff\" to see what changed in this commit; but answer 3 is good: short, descriptive, and imperative.</p> <p>Committing Changes to Git</p> <p>Which command(s) below would save the changes of <code>myfile.txt</code> to my local Git repository?</p> <ol> <li> <p><code>bash     $ git commit -m \"my recent changes\"</code></p> </li> <li> <p><code>bash     $ git init myfile.txt     $ git commit -m \"my recent changes\"</code></p> </li> <li> <p><code>bash     $ git add myfile.txt     $ git commit -m \"my recent changes\"</code></p> </li> <li> <p><code>bash     $ git commit -m myfile.txt \"my recent changes\"</code></p> </li> </ol> Solution <ol> <li>Would only create a commit if files have already been staged.</li> <li>Would try to create a new repository.</li> <li>Is correct: first add the file to the staging area, then commit.</li> <li>Would try to commit a file \"my recent changes\" with the message myfile.txt.</li> </ol> <p>Committing Multiple Files</p> <p>The staging area can hold changes from any number of files that you want to commit as a single snapshot.</p> <ol> <li>Add a step 3 to <code>README.txt</code></li> <li>Create a new file <code>metadata.txt</code> with a very brief description of the dataset</li> <li>Add changes from both files to the staging area, and commit those changes.</li> </ol> Solution <p>The output below from <code>cat README.txt</code> reflects only content added during this exercise. Your output may vary.</p> <p>First we make our changes to the <code>README.txt</code> and <code>venus.txt</code> files:</p> <p>code</p> <pre><code>$ nano README.txt\n$ cat README.txt\n</code></pre> <pre><code>Project notes for the variant calling workflow\n\n1. Perform QC\n2. Align reads\n3. Variant call\n</code></pre> <pre><code>$ nano metadata.txt\n$ cat metadata.txt\n</code></pre> <pre><code>Genome sequences of 3 E. coli samples.\n</code></pre> <p>Now you can add both files to the staging area. We can do that in one line:</p> <p>code</p> <pre><code>$ git add README.txt metadata.txt\n</code></pre> <p>Or with multiple commands:</p> <p>code</p> <pre><code>$ git add README.txt\n$ git add metadata.txt\n</code></pre> <p>Now the files are ready to commit. You can check that using <code>git status</code>. If you are ready to commit use:</p> <p>code</p> <pre><code>$ git commit -m \"Include metadata\"\n</code></pre> <pre><code>[main cc127c2]\nInclude metdata\n2 files changed, 2 insertions(+)\ncreate mode 100644 metadata.txt\n</code></pre> <p><code>bio</code> Repository</p> <ul> <li>Create a new Git repository on your computer called <code>bio</code>.</li> <li>Write a three-line biography for yourself in a file called <code>me.txt</code>, commit your changes</li> <li>Modify one line, add a fourth line</li> <li>Display the differences between its updated state and its original state.</li> </ul> Solution <p>If needed, move out of the <code>planets</code> folder:</p> <pre><code>$ cd ..\n</code></pre> <p>Create a new folder called <code>bio</code> and 'move' into it:</p> <pre><code>$ mkdir bio\n$ cd bio\n</code></pre> <p>Initialise git:</p> <pre><code>$ git init\n</code></pre> <p>Create your biography file <code>me.txt</code> using <code>nano</code> or another text editor. Once in place, add and commit it to the repository:</p> <pre><code>$ git add me.txt\n$ git commit -m \"Add biography file\"\n</code></pre> <p>Modify the file as described (modify one line, add a fourth line). To display the differences between its updated state and its original state, use <code>git diff</code>:</p> <pre><code>$ git diff me.txt\n</code></pre> <p>!!! info Keypoints\"</p> <pre><code>  - `git status` shows the status of a repository.\n  - Files can be stored in a project's working directory (which users see), the staging area (where the next commit is being built up) and the local repository (where commits are permanently recorded).\n  - `git add` puts files in the staging area.\n  - `git commit` saves the staged content as a new commit in the local repository.\n  - Write a commit message that accurately describes your changes.\n</code></pre>"},{"location":"5_history/","title":"Exploring History","text":"<p>title: Exploring History teaching: 25 exercises: 0</p> <p>Objectives</p> <ul> <li>Explain what the HEAD of a repository is and how to use it.</li> <li>Identify and use Git commit numbers.</li> <li>Compare various versions of tracked files.</li> <li>Restore old versions of files.</li> </ul> <p>As we saw in the previous episode, we can refer to commits by their identifiers. You can refer to the most recent commit of the working directory by using the identifier <code>HEAD</code>.</p> <p>We've been adding one line at a time to <code>README.txt</code>, so it's easy to track our progress by looking, so let's do that using our <code>HEAD</code>s. Before we start, let's make a change to <code>README.txt</code>, adding yet another line.</p> <p>code</p> <pre><code>$ nano README.txt\n$ cat README.txt\n</code></pre> <pre><code>Project notes for the variant calling workflow\n\n1. Perform QC\n2. Align reads\n3. Variant call\n4. Variant filtering\n</code></pre> <p>Now, let's see what we get.</p> <p>code</p> <pre><code>$ git diff HEAD README.txt\n</code></pre> <pre><code>diff --git a/README.txt b/README.txt\nindex b36abfd..0848c8d 100644\n--- a/README.txt\n+++ b/README.txt\n@@ -3,3 +3,4 @@\nProject notes for the variant calling workflow\n\n1. Perform QC\n2. Align reads\n3. Variant call\n+4. Variant filtering\n</code></pre> <p>which is the same as what you would get if you leave out <code>HEAD</code> (try it). The real goodness in all this is when you can refer to previous commits. We do that by adding <code>~1</code> (where \"~\" is \"tilde\", pronounced [til-d*uh*]) to refer to the commit one before <code>HEAD</code>.</p> <p>code</p> <pre><code>$ git diff HEAD~1 README.txt\n</code></pre> <p>If we want to see the differences between older commits we can use <code>git diff</code> again, but with the notation <code>HEAD~1</code>, <code>HEAD~2</code>, and so on, to refer to them:</p> <p>code</p> <pre><code>$ git diff HEAD~4 README.txt\n</code></pre> <pre><code>diff --git a/README.txt b/README.txt\nindex df0654a..b36abfd 100644\n--- a/README.txt\n+++ b/README.txt\n@@ -1 +1,6 @@\nProject notes for the variant calling workflow\n+\n+1. Perform QC\n+2. Align reads\n+3. Variant call\n+4. Variant filtering\n</code></pre> <p>We could also use <code>git show</code> which shows us what changes we made at an older commit as well as the commit message, rather than the differences between a commit and our working directory that we see by using <code>git diff</code>.</p> <p>code</p> <pre><code>$ git show HEAD~4 README.txt\n</code></pre> <pre><code>commit f22b25e3233b4645dabd0d81e651fe074bd8e73b\nAuthor: Vlad Dracula &lt;vlad@tran.sylvan.ia&gt;\nDate:   Thu Aug 22 09:51:46 2013 -0400\n\n    Start notes project\n\ndiff --git a/README.txt b/README.txt\nnew file mode 100644\nindex 0000000..df0654a\n--- /dev/null\n+++ b/README.txt\n@@ -0,0 +1 @@\n+Project notes for the variant calling workflow\n</code></pre> <p>In this way, we can build up a chain of commits. The most recent end of the chain is referred to as <code>HEAD</code>; we can refer to previous commits using the <code>~</code> notation, so <code>HEAD~1</code> means \"the previous commit\", while <code>HEAD~123</code> goes back 123 commits from where we are now.</p> <p>We can also refer to commits using those long strings of digits and letters that <code>git log</code> displays. These are unique IDs for the changes, and \"unique\" really does mean unique: every change to any set of files on any computer has a unique 40-character identifier. Our first commit was given the ID <code>f22b25e3233b4645dabd0d81e651fe074bd8e73b</code>, so let's try this:</p> <p>code</p> <pre><code>$ git diff f22b25e3233b4645dabd0d81e651fe074bd8e73b README.txt\n</code></pre> <pre><code>diff --git a/README.txt b/README.txt\nindex df0654a..93a3e13 100644\n--- a/README.txt\n+++ b/README.txt\n@@ -1 +1,6 @@\nProject notes for the variant calling workflow\n+\n+1. Perform QC\n+2. Align reads\n+3. Variant call\n+4. Variant filtering\n</code></pre> <p>That's the right answer, but typing out random 40-character strings is annoying, so Git lets us use just the first few characters (typically seven for normal size projects):</p> <p>code</p> <pre><code>$ git diff f22b25e README.txt\n</code></pre> <pre><code>diff --git a/README.txt b/README.txt\nindex df0654a..93a3e13 100644\n--- a/README.txt\n+++ b/README.txt\n@@ -1 +1,6 @@\nProject notes for the variant calling workflow\n+\n+1. Perform QC\n+2. Align reads\n+3. Variant call\n+4. Variant filtering\n</code></pre> <p>All right! So we can save changes to files and see what we've changed. Now, how can we restore older versions of things? Let's suppose we change our mind about the last update to <code>README.txt</code> (the \"ill-considered change\").</p> <p><code>git status</code> now tells us that the file has been changed, but those changes haven't been staged:</p> <p>code</p> <pre><code>$ git status\n</code></pre> <pre><code>On branch main\nChanges not staged for commit:\n(use \"git add &lt;file&gt;...\" to update what will be committed)\n(use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n    modified:   README.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n</code></pre> <p>We can put things back the way they were by using <code>git checkout</code>:</p> <p>code</p> <pre><code>$ git checkout HEAD README.txt\n$ cat README.txt\n</code></pre> <pre><code>Project notes for the variant calling workflow\n\n1. Perform QC\n2. Align reads\n3. Variant call\n</code></pre> <p>As you might guess from its name, <code>git checkout</code> checks out (i.e., restores) an old version of a file. In this case, we're telling Git that we want to recover the version of the file recorded in <code>HEAD</code>, which is the last saved commit. If we want to go back even further, we can use a commit identifier instead:</p> <p>code</p> <pre><code>$ git checkout f22b25e README.txt\n</code></pre> <pre><code>$ cat README.txt\n</code></pre> <pre><code>Project notes for the variant calling workflow\n</code></pre> <pre><code>$ git status\n</code></pre> <pre><code>On branch main\nChanges to be committed:\n(use \"git reset HEAD &lt;file&gt;...\" to unstage)\n\n    modified:   README.txt\n</code></pre> <p>Notice that the changes are currently in the staging area. Again, we can put things back the way they were by using <code>git checkout</code>:</p> <p>code</p> <pre><code>$ git checkout HEAD README.txt\n</code></pre> <p>Don't Lose Your HEAD</p> <p>Above we used</p> <p>code</p> <pre><code>$ git checkout f22b25e README.txt\n</code></pre> <p>to revert <code>README.txt</code> to its state after the commit <code>f22b25e</code>. But be careful! The command <code>checkout</code> has other important functionalities and Git will misunderstand your intentions if you are not accurate with the typing. For example, if you forget <code>README.txt</code> in the previous command.</p> <p>code</p> <pre><code>$ git checkout f22b25e\n</code></pre> <pre><code>Note: checking out 'f22b25e'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by performing another checkout.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -b with the checkout command again. Example:\n\ngit checkout -b &lt;new-branch-name&gt;\n\nHEAD is now at f22b25e Start notes on Mars as a base\n</code></pre> <p>The \"detached HEAD\" is like \"look, but don't touch\" here, so you shouldn't make any changes in this state. After investigating your repo's past state, reattach your <code>HEAD</code> with <code>git checkout main</code>.</p> <p>It's important to remember that we must use the commit number that identifies the state of the repository before the change we're trying to undo. A common mistake is to use the number of the commit in which we made the change we're trying to discard. In the example below, we want to retrieve the state from before the most recent commit (<code>HEAD~1</code>), which is commit <code>f22b25e</code>:</p> <p></p> <p>So, to put it all together, here's how Git works in cartoon form:</p> <p></p> <p>Simplifying the Common Case</p> <p>If you read the output of <code>git status</code> carefully, you'll see that it includes this hint:</p> <pre><code>(use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n</code></pre> <p>As it says, <code>git checkout</code> without a version identifier restores files to the state saved in <code>HEAD</code>. The double dash <code>--</code> is needed to separate the names of the files being recovered from the command itself: without it, Git would try to use the name of the file as the commit identifier.</p> <p>The fact that files can be reverted one by one tends to change the way people organize their work. If everything is in one large document, it's hard (but not impossible) to undo changes to the introduction without also undoing changes made later to the conclusion. If the introduction and conclusion are stored in separate files, on the other hand, moving backward and forward in time becomes much easier.</p> <p>Recovering Older Versions of a File</p> <p>Jennifer has made changes to the Python script that she has been working on for weeks, and the modifications she made this morning \"broke\" the script and it no longer runs. She has spent ~ 1hr trying to fix it, with no luck...</p> <p>Luckily, she has been keeping track of her project's versions using Git! Which commands below will let her recover the last committed version of her Python script called <code>data_cruncher.py</code>?</p> <ol> <li> <p><code>$ git checkout HEAD</code></p> </li> <li> <p><code>$ git checkout HEAD data_cruncher.py</code></p> </li> <li> <p><code>$ git checkout HEAD~1 data_cruncher.py</code></p> </li> <li> <p><code>$ git checkout &lt;unique ID of last commit&gt; data_cruncher.py</code></p> </li> <li> <p>Both 2 and 4</p> </li> </ol> Solution <p>The answer is (5)-Both 2 and 4.</p> <p>The <code>checkout</code> command restores files from the repository, overwriting the files in your working directory. Answers 2 and 4 both restore the latest version in the repository of the file <code>data_cruncher.py</code>. Answer 2 uses <code>HEAD</code> to indicate the latest, whereas answer 4 uses the unique ID of the last commit, which is what <code>HEAD</code> means.</p> <p>Answer 3 gets the version of <code>data_cruncher.py</code> from the commit before <code>HEAD</code>, which is NOT what we wanted.</p> <p>Answer 1 can be dangerous! Without a filename, <code>git checkout</code> will restore all files in the current directory (and all directories below it) to their state at the commit specified. This command will restore <code>data_cruncher.py</code> to the latest commit version, but it will also restore any other files that are changed to that version, erasing any changes you may have made to those files! As discussed above, you are left in a detached <code>HEAD</code> state, and you don't want to be there.</p> <p>Reverting a Commit</p> <p>Jennifer is collaborating with colleagues on her Python script. She realizes her last commit to the project's repository contained an error, and wants to undo it. Jennifer wants to undo correctly so everyone in the project's repository gets the correct change. The command <code>git revert [erroneous commit ID]</code> will create a new commit that reverses the erroneous commit.</p> <p>The command <code>git revert</code> is different from <code>git checkout [commit ID]</code> because <code>git checkout</code> returns the files not yet committed within the local repository to a previous state, whereas <code>git revert</code> reverses changes committed to the local and project repositories.</p> <p>Below are the right steps and explanations for Jennifer to use <code>git revert</code>, what is the missing command?</p> <ol> <li> <p><code>________ # Look at the git history of the project to find the commit ID</code></p> </li> <li> <p>Copy the ID (the first few characters of the ID, e.g. 0b1d055).</p> </li> <li> <p><code>git revert [commit ID]</code></p> </li> <li> <p>Type in the new commit message.</p> </li> <li> <p>Save and close</p> Solution <p>The command <code>git log</code> lists project history with commit IDs.</p> <p>The command <code>git show HEAD</code> shows changes made at the latest commit, and lists the commit ID; however, Jennifer should double-check it is the correct commit, and no one else has committed changes to the repository.</p> </li> </ol> <p>Understanding Workflow and History</p> <p>What is the output of the last command in</p> <p>code</p> <pre><code>$ cd planets\n$ echo \"Venus is beautiful and full of love\" &gt; venus.txt\n$ git add venus.txt\n$ echo \"Venus is too hot to be suitable as a base\" &gt;&gt; venus.txt\n$ git commit -m \"Comment on Venus as an unsuitable base\"\n$ git checkout HEAD venus.txt\n$ cat venus.txt #this will print the contents of venus.txt to the screen\n</code></pre> <ol> <li> <pre><code>Venus is too hot to be suitable as a base\n</code></pre> </li> <li> <pre><code>```output\nVenus is beautiful and full of love\n```\n</code></pre> </li> <li> <pre><code>```output\nVenus is beautiful and full of love\nVenus is too hot to be suitable as a base\n```\n</code></pre> </li> <li> <pre><code>```output\nError because you have changed venus.txt without committing the changes\n```\n</code></pre> </li> </ol> Solution <p>The answer is 2.</p> <p>The command <code>git add venus.txt</code> places the current version of <code>venus.txt</code> into the staging area. The changes to the file from the second <code>echo</code> command are only applied to the working copy, not the version in the staging area.</p> <p>So, when <code>git commit -m \"Comment on Venus as an unsuitable base\"</code> is executed, the version of <code>venus.txt</code> committed to the repository is the one from the staging area and has only one line.</p> <p>At this time, the working copy still has the second line (and <code>git status</code> will show that the file is modified). However, <code>git checkout HEAD venus.txt</code> replaces the working copy with the most recently committed version of <code>venus.txt</code>.</p> <p>So, <code>cat venus.txt</code> will output</p> <pre><code>Venus is beautiful and full of love.\n</code></pre> <p>Checking Understanding of <code>git diff</code></p> <p>Consider this command: <code>git diff HEAD~9 README.txt</code>. What do you predict this command will do if you execute it? What happens when you do execute it? Why?</p> <p>Try another command, <code>git diff [ID] README.txt</code>, where [ID] is replaced with the unique identifier for your most recent commit. What do you think will happen, and what does happen?</p> <p>Getting Rid of Staged Changes</p> <p><code>git checkout</code> can be used to restore a previous commit when unstaged changes have been made, but will it also work for changes that have been staged but not committed? Make a change to <code>README.txt</code>, add that change using <code>git add</code>, then use <code>git checkout</code> to see if you can remove your change.</p> Solution <p>After adding a change, <code>git checkout</code> can not be used directly. Let's look at the output of <code>git status</code>:</p> <pre><code>On branch main\nChanges to be committed:\n(use \"git reset HEAD &lt;file&gt;...\" to unstage)\n\n        modified:   README.txt\n</code></pre> <p>Note that if you don't have the same output you may either have forgotten to change the file, or you have added it and committed it.</p> <p>Using the command <code>git checkout -- README.txt</code> now does not give an error, but it does not restore the file either. Git helpfully tells us that we need to use <code>git reset</code> first to unstage the file:</p> <p>code</p> <pre><code>$ git reset HEAD README.txt\n</code></pre> <pre><code>Unstaged changes after reset:\nM   README.txt\n</code></pre> <p>Now, <code>git status</code> gives us:</p> <p>code</p> <pre><code>$ git status\n</code></pre> <pre><code>On branch main\nChanges not staged for commit:\n(use \"git add &lt;file&gt;...\" to update what will be committed)\n(use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory)\n\n        modified:   README.txt\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n</code></pre> <p>This means we can now use <code>git checkout</code> to restore the file to the previous commit:</p> <p>code</p> <pre><code>$ git checkout -- README.txt\n$ git status\n</code></pre> <pre><code>On branch main\nnothing to commit, working tree clean\n</code></pre> <p>Explore and Summarize Histories</p> <p>Exploring history is an important part of Git, and often it is a challenge to find the right commit ID, especially if the commit is from several months ago.</p> <p>Imagine the <code>vc_project</code> project has more than 50 files. You would like to find a commit that modifies some specific text in <code>README.txt</code>. When you type <code>git log</code>, a very long list appeared. How can you narrow down the search?</p> <p>Recall that the <code>git diff</code> command allows us to explore one specific file, e.g., <code>git diff README.txt</code>. We can apply a similar idea here.</p> <p>code</p> <pre><code>$ git log README.txt\n</code></pre> <p>Unfortunately some of these commit messages are very ambiguous, e.g., <code>update files</code>. How can you search through these files?</p> <p>Both <code>git diff</code> and <code>git log</code> are very useful and they summarize a different part of the history for you. Is it possible to combine both? Let's try the following:</p> <p>code</p> <pre><code>$ git log --patch README.txt\n</code></pre> <p>You should get a long list of output, and you should be able to see both commit messages and the difference between each commit.</p> <p>Question: What does the following command do?</p> <p>code</p> <pre><code>$ git log --patch HEAD~9 *.txt\n</code></pre> <p>Keypoints</p> <ul> <li><code>git diff</code> displays differences between commits.</li> <li><code>git checkout</code> recovers old versions of files.</li> </ul>"},{"location":"6_ignoring_things/","title":"Ignoring Things","text":"<p>title: Ignoring Things teaching: 5 exercises: 0</p> <p>Objectives</p> <ul> <li>Configure Git to ignore specific files.</li> <li>Explain why ignoring files can be useful.</li> </ul> <p>What if we have files that we do not want Git to track for us, like backup files created by our editor or intermediate files created during data analysis? Let's create a few dummy files:</p> <p>code</p> <pre><code>$ mkdir results\n$ touch a.csv b.csv c.csv results/a.out results/b.out\n</code></pre> <p>and see what Git says:</p> <p>code</p> <pre><code>$ git status\n</code></pre> <pre><code>On branch main\nUntracked files:\n(use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    a.csv\n    b.csv\n    c.csv\n    results/\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n</code></pre> <p>Putting these files under version control would be a waste of disk space. What's worse, having them all listed could distract us from changes that actually matter, so let's tell Git to ignore them.</p> <p>We do this by creating a file in the root directory of our project called <code>.gitignore</code>:</p> <p>code</p> <pre><code>$ nano .gitignore\n$ cat .gitignore\n</code></pre> <pre><code>*.csv\nresults/\n</code></pre> <p>These patterns tell Git to ignore any file whose name ends in <code>.csv</code> and everything in the <code>results</code> directory. (If any of these files were already being tracked, Git would continue to track them.)</p> <p>Once we have created this file, the output of <code>git status</code> is much cleaner:</p> <p>code</p> <pre><code>$ git status\n</code></pre> <pre><code>On branch main\nUntracked files:\n(use \"git add &lt;file&gt;...\" to include in what will be committed)\n\n    .gitignore\n\nnothing added to commit but untracked files present (use \"git add\" to track)\n</code></pre> <p>The only thing Git notices now is the newly-created <code>.gitignore</code> file. You might think we wouldn't want to track it, but everyone we're sharing our repository with will probably want to ignore the same things that we're ignoring. Let's add and commit <code>.gitignore</code>:</p> <p>code</p> <pre><code>$ git add .gitignore\n$ git commit -m \"Ignore data files and the results folder\"\n$ git status\n</code></pre> <pre><code>On branch main\nnothing to commit, working tree clean\n</code></pre> <p>As a bonus, using <code>.gitignore</code> helps us avoid accidentally adding files to the repository that we don't want to track:</p> <p>code</p> <pre><code>$ git add a.csv\n</code></pre> <pre><code>The following paths are ignored by one of your .gitignore files:\na.csv\nUse -f if you really want to add them.\n</code></pre> <p>If we really want to override our ignore settings, we can use <code>git add -f</code> to force Git to add something. For example, <code>git add -f a.csv</code>. We can also always see the status of ignored files if we want:</p> <p>code</p> <pre><code>$ git status --ignored\n</code></pre> <pre><code>On branch main\nIgnored files:\n(use \"git add -f &lt;file&gt;...\" to include in what will be committed)\n\n        a.csv\n        b.csv\n        c.csv\n        results/\n\nnothing to commit, working tree clean\n</code></pre> <p>Ignoring Nested Files</p> <p>Given a directory structure that looks like:</p> <p>Terminal-2</p> <pre><code>results/data\nresults/plots\n</code></pre> <p>How would you ignore only <code>results/plots</code> and not <code>results/data</code>?</p> Solution <p>If you only want to ignore the contents of <code>results/plots</code>, you can change your <code>.gitignore</code> to ignore only the <code>/plots/</code> subfolder by adding the following line to your .gitignore:</p> <pre><code>results/plots/\n</code></pre> <p>This line will ensure only the contents of <code>results/plots</code> is ignored, and not the contents of <code>results/data</code>.</p> <p>As with most programming issues, there are a few alternative ways that one may ensure this ignore rule is followed. The \"Ignoring Nested Files: Variation\" exercise has a slightly different directory structure that presents an alternative solution. Further, the discussion page has more detail on ignore rules.</p> <p>Including Specific Files</p> <p>How would you ignore all <code>.csv</code> files in your root directory except for <code>final.csv</code>? Hint: Find out what <code>!</code> (the exclamation point operator) does</p> Solution <p>You would add the following two lines to your .gitignore:</p> <pre><code>*.csv           # ignore all data files\n!final.csv      # except final.csv\n</code></pre> <p>The exclamation point operator will include a previously excluded entry.</p> <p>Note also that because you've previously committed <code>.csv</code> files in this lesson they will not be ignored with this new rule. Only future additions of <code>.csv</code> files added to the root directory will be ignored.</p> <p>Ignoring Nested Files: Variation</p> <p>Given a directory structure that looks similar to the earlier Nested Files exercise, but with a slightly different directory structure:</p> <p>code</p> <pre><code>results/data\nresults/images\nresults/plots\nresults/analysis\n</code></pre> <p>How would you ignore all of the contents in the results folder, but not <code>results/data</code>?</p> <p>Hint: think a bit about how you created an exception with the <code>!</code> operator before.</p> Solution <p>If you want to ignore the contents of <code>results/</code> but not those of <code>results/data/</code>, you can change your <code>.gitignore</code> to ignore the contents of results folder, but create an exception for the contents of the <code>results/data</code> subfolder. Your .gitignore would look like this:</p> <pre><code>results/*               # ignore everything in results folder\n!results/data/          # do not ignore results/data/ contents\n</code></pre> <p>File-code</p> <p>Assuming you have an empty .gitignore file, and given a directory structure that looks like:</p> <p>code</p> <pre><code>results/data/position/gps/a.csv\nresults/data/position/gps/b.csv\nresults/data/position/gps/c.csv\nresults/data/position/gps/info.txt\nresults/plots\n</code></pre> <p>What's the shortest <code>.gitignore</code> rule you could write to ignore all <code>.csv</code> files in <code>result/data/position/gps</code>? Do not ignore the <code>info.txt</code>.</p> Solution <p>Appending <code>results/data/position/gps/*.csv</code> will match every file in <code>results/data/position/gps</code> that ends with <code>.csv</code>. The file <code>results/data/position/gps/info.txt</code> will not be ignored.</p> <p>Ignoring all data Files in the repository</p> <p>Let us assume you have many <code>.csv</code> files in different subdirectories of your repository. For example, you might have:</p> <p>code</p> <pre><code>results/a.csv\ndata/experiment_1/b.csv\ndata/experiment_2/c.csv\ndata/experiment_2/variation_1/d.csv\n</code></pre> <p>How do you ignore all the <code>.csv</code> files, without explicitly listing the names of the corresponding folders?</p> Solution <p>In the <code>.gitignore</code> file, write:</p> <pre><code>**/*.csv\n</code></pre> <p>This will ignore all the <code>.csv</code> files, regardless of their position in the directory tree. You can still include some specific exception with the exclamation point operator.</p> <p>The Order of Rules</p> <p>Given a <code>.gitignore</code> file with the following contents:</p> <pre><code>*.csv\n!*.csv\n</code></pre> <p>What will be the result?</p> Solution <p>The <code>!</code> modifier will negate an entry from a previously defined ignore pattern. Because the <code>!*.csv</code> entry negates all of the previous <code>.csv</code> files in the <code>.gitignore</code>, one of them will be ignored, and all <code>.csv</code> files will be tracked.</p> <p>Log Files</p> <p>You wrote a script that creates many intermediate log-files of the form <code>log_01</code>, <code>log_02</code>, <code>log_03</code>, etc. You want to keep them but you do not want to track them through <code>git</code>.</p> <ol> <li> <p>Write one <code>.gitignore</code> entry that excludes files of the form <code>log_01</code>, <code>log_02</code>, etc.</p> </li> <li> <p>Test your \"ignore pattern\" by creating some dummy files of the form <code>log_01</code>, etc.</p> </li> <li> <p>You find that the file <code>log_01</code> is very important after all, add it to the tracked files without changing the <code>.gitignore</code> again.</p> </li> <li> <p>Discuss with your neighbor what other types of files could reside in your directory that you do not want to track and thus would exclude via <code>.gitignore</code>.</p> </li> </ol> Solution <ol> <li>append either <code>log_*</code> or <code>log*</code> as a new entry in your .gitignore</li> <li>track <code>log_01</code> using <code>git add -f log_01</code></li> </ol> <p>Keypoints</p> <ul> <li>The <code>.gitignore</code> file tells Git what files to ignore.</li> </ul>"},{"location":"7_remotes/","title":"Remotes in Github","text":"<p>Objectives</p> <ul> <li>Explain what remote repositories are and why they are useful.</li> <li>Push to or pull from a remote repository.</li> </ul> <p>Version control really comes into its own when we begin to collaborate with other people. We already have most of the machinery we need to do this; the only thing missing is to copy changes from one repository to another.</p> <p>Systems like Git allow us to move work between any two repositories. In practice, though, it's easiest to use one copy as a central hub, and to keep it on the web rather than on someone's laptop. Most programmers use hosting services like GitHub, Bitbucket or GitLab to hold those main copies; we'll explore the pros and cons of this in a later episode.</p> <p>Let's start by sharing the changes we've made to our current project with the world. To this end we are going to create a remote repository that will be linked to our local repository.</p>"},{"location":"7_remotes/#1-create-a-remote-repository","title":"1. Create a remote repository","text":"<p>Log in to GitHub, then click on the icon in the top right corner to create a new repository called <code>planets</code>:</p> <p></p> <p>Name your repository \"planets\" and then click \"Create Repository\".</p> <p>Note: Since this repository will be connected to a local repository, it needs to be empty. Leave \"Initialize this repository with a README\" unchecked, and keep \"None\" as options for both \"Add .gitignore\" and \"Add a license.\" See the \"GitHub License and README files\" exercise below for a full explanation of why the repository needs to be empty.</p> <p></p> <p>As soon as the repository is created, GitHub displays a page with a URL and some information on how to configure your local repository:</p> <p></p> <p>This effectively does the following on GitHub's servers:</p> <pre><code>$ mkdir vc_project\n$ cd vc_project\n$ git init\n</code></pre> <p>If you remember back to the earlier episode where we added and committed our earlier work on <code>README.txt</code>, we had a diagram of the local repository which looked like this:</p> <p></p> <p>Now that we have two repositories, we need a diagram like this:</p> <p></p> <p>Note that our local repository still contains our earlier work on <code>README.txt</code>, but the remote repository on GitHub appears empty as it doesn't contain any files yet.</p>"},{"location":"7_remotes/#2-connect-local-to-remote-repository","title":"2. Connect local to remote repository","text":"<p>Now we connect the two repositories. We do this by making the GitHub repository a remote for the local repository. The home page of the repository on GitHub includes the URL string we need to identify it:</p> <p></p> <p>Click on the 'SSH' link to change the protocol from HTTPS to SSH.</p> <p>HTTPS vs. SSH</p> <p>We use SSH here because, while it requires some additional configuration, it is a security protocol widely used by many applications. The steps below describe SSH at a minimum level for GitHub.</p> <p></p> <p>Copy that URL from the browser, go into the local <code>vc_project</code> repository, and run this command:</p> <pre><code>$ git remote add origin git@github.com:vlad/vc_project.git\n</code></pre> <p>Make sure to use the URL for your repository rather than Vlad's: the only difference should be your username instead of <code>vlad</code>.</p> <p><code>origin</code> is a local name used to refer to the remote repository. It could be called anything, but <code>origin</code> is a convention that is often used by default in git and GitHub, so it's helpful to stick with this unless there's a reason not to.</p> <p>We can check that the command has worked by running <code>git remote -v</code>:</p> <pre><code>$ git remote -v\n</code></pre> <pre><code>origin   git@github.com:vlad/vc_project.git (fetch)\norigin   git@github.com:vlad/vc_project.git (push)\n</code></pre> <p>We'll discuss remotes in more detail in the next episode, while talking about how they might be used for collaboration.</p>"},{"location":"7_remotes/#3-ssh-background-and-setup","title":"3. SSH Background and Setup","text":"<p>Before Dracula can connect to a remote repository, he needs to set up a way for his computer to authenticate with GitHub so it knows it's him trying to connect to his remote repository.</p> <p>We are going to set up the method that is commonly used by many different services to authenticate access on the command line. This method is called Secure Shell Protocol (SSH). SSH is a cryptographic network protocol that allows secure communication between computers using an otherwise insecure network.</p> <p>SSH uses what is called a key pair. This is two keys that work together to validate access. One key is publicly known and called the public key, and the other key called the private key is kept private. Very descriptive names.</p> <p>You can think of the public key as a padlock, and only you have the key (the private key) to open it. You use the public key where you want a secure method of communication, such as your GitHub account. You give this padlock, or public key, to GitHub and say \"lock the communications to my account with this so that only computers that have my private key can unlock communications and send git commands as my GitHub account.\"</p> <p>What we will do now is the minimum required to set up the SSH keys and add the public key to a GitHub account.</p> <p>Advanced SSH</p> <p>A supplemental episode in this lesson discusses SSH and key pairs in more depth and detail.</p> <p>The first thing we are going to do is check if this has already been done on the computer you're on. Because generally speaking, this setup only needs to happen once and then you can forget about it.</p> <p>Keeping your keys secure</p> <p>You shouldn't really forget about your SSH keys, since they keep your account secure. It's good practice to audit your secure shell keys every so often. Especially if you are using multiple computers to access your account.</p> <p>We will run the list command to check what key pairs already exist on your computer.</p> <p>code</p> <pre><code>ls -al ~/.ssh\n</code></pre> <p>Your output is going to look a little different depending on whether or not SSH has ever been set up on the computer you are using.</p> <p>Dracula has not set up SSH on his computer, so his output is</p> <p>code</p> <pre><code>ls: cannot access '/c/Users/Vlad Dracula/.ssh': No such file or directory\n</code></pre> <p>If SSH has been set up on the computer you're using, the public and private key pairs will be listed. The file names are either <code>id_ed25519</code>/<code>id_ed25519.pub</code> or <code>id_rsa</code>/<code>id_rsa.pub</code> depending on how the key pairs were set up. Since they don't exist on Dracula's computer, he uses this command to create them.</p>"},{"location":"7_remotes/#31-create-an-ssh-key-pair","title":"3.1 Create an SSH key pair","text":"<p>To create an SSH key pair Vlad uses this command, where the <code>-t</code> option specifies which type of algorithm to use and <code>-C</code> attaches a comment to the key (here, Vlad's email):</p> <p>code</p> <pre><code>$ ssh-keygen -t ed25519 -C \"vlad@tran.sylvan.ia\"\n</code></pre> <p>If you are using a legacy system that doesn't support the Ed25519 algorithm, use: <code>$ ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"</code></p> <p>code</p> <pre><code>Generating public/private ed25519 key pair.\nEnter file in which to save the key (/home/&lt;username&gt;/.ssh/id_ed25519):\n</code></pre> <p>We want to use the default file, so just press Enter.</p> <p>code</p> <pre><code>Created directory '/home/&lt;username&gt;/.ssh'.\nEnter passphrase (empty for no passphrase):\n</code></pre> <p>Now, it is prompting Dracula for a passphrase. Since he is using his lab's laptop that other people sometimes have access to, he wants to create a passphrase. Be sure to use something memorable or save your passphrase somewhere, as there is no \"reset my password\" option.</p> <p>code</p> <pre><code>Enter same passphrase again:\n</code></pre> <p>After entering the same passphrase a second time, we receive the confirmation</p> <p>code</p> <pre><code>Your identification has been saved in /c/Users/Vlad Dracula/.ssh/id_ed25519\nYour public key has been saved in /c/Users/Vlad Dracula/.ssh/id_ed25519.pub\nThe key fingerprint is:\nSHA256:SMSPIStNyA00KPxuYu94KpZgRAYjgt9g4BA4kFy3g1o vlad@tran.sylvan.ia\nThe key's randomart image is:\n+--[ED25519 256]--+\n|^B== o.          |\n|%*=.*.+          |\n|+=.E =.+         |\n| .=.+.o..        |\n|....  . S        |\n|.+ o             |\n|+ =              |\n|.o.o             |\n|oo+.             |\n+----[SHA256]-----+\n</code></pre> <p>The \"identification\" is actually the private key. You should never share it. The public key is appropriately named. The \"key fingerprint\" is a shorter version of a public key.</p> <p>Now that we have generated the SSH keys, we will find the SSH files when we check.</p> <p>code</p> <pre><code>ls -al ~/.ssh\n</code></pre> <pre><code>drwxr-xr-x 1 Vlad Dracula 197121   0 Jul 16 14:48 ./\ndrwxr-xr-x 1 Vlad Dracula 197121   0 Jul 16 14:48 ../\n-rw-r--r-- 1 Vlad Dracula 197121 419 Jul 16 14:48 id_ed25519\n-rw-r--r-- 1 Vlad Dracula 197121 106 Jul 16 14:48 id_ed25519.pub\n</code></pre>"},{"location":"7_remotes/#32-copy-the-public-key-to-github","title":"3.2 Copy the public key to GitHub","text":"<p>Now we have a SSH key pair and we can run this command to check if GitHub can read our authentication.</p> <p>code</p> <pre><code>ssh -T git@github.com\n</code></pre> <pre><code>The authenticity of host 'github.com (192.30.255.112)' can't be established.\nRSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\nThis key is not known by any other names\nAre you sure you want to continue connecting (yes/no/[fingerprint])? y\nPlease type 'yes', 'no' or the fingerprint: yes\nWarning: Permanently added 'github.com' (RSA) to the list of known hosts.\ngit@github.com: Permission denied (publickey).\n</code></pre> <p>Right, we forgot that we need to give GitHub our public key!</p> <p>First, we need to copy the public key. Be sure to include the <code>.pub</code> at the end, otherwise you're looking at the private key.</p> <p>code</p> <pre><code>cat ~/.ssh/id_ed25519.pub\n</code></pre> <pre><code>ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDmRA3d51X0uu9wXek559gfn6UFNF69yZjChyBIU2qKI vlad@tran.sylvan.ia\n</code></pre> <p>Now, going to GitHub.com, click on your profile icon in the top right corner to get the drop-down menu. Click \"Settings,\" then on the settings page, click \"SSH and GPG keys,\" on the left side \"Account settings\" menu. Click the \"New SSH key\" button on the right side. Now, you can add the title (Dracula uses the title \"Vlad's Lab Laptop\" so he can remember where the original key pair files are located), paste your SSH key into the field, and click the \"Add SSH key\" to complete the setup.</p> <p>Now that we've set that up, let's check our authentication again from the command line.</p> <p>code</p> <pre><code>$ ssh -T git@github.com\n</code></pre> <pre><code>Hi Vlad! You've successfully authenticated, but GitHub does not provide shell access.\n</code></pre> <p>Good! This output confirms that the SSH key works as intended. We are now ready to push our work to the remote repository.</p>"},{"location":"7_remotes/#4-push-local-changes-to-a-remote","title":"4. Push local changes to a remote","text":"<p>Now that authentication is setup, we can return to the remote. This command will push the changes from our local repository to the repository on GitHub:</p> <p>code</p> <pre><code>$ git push origin main\n</code></pre> <p>Since Dracula set up a passphrase, it will prompt him for it. If you completed advanced settings for your authentication, it will not prompt for a passphrase.</p> <p>code</p> <pre><code>Enumerating objects: 16, done.\nCounting objects: 100% (16/16), done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (11/11), done.\nWriting objects: 100% (16/16), 1.45 KiB | 372.00 KiB/s, done.\nTotal 16 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), done.\nTo https://github.com/vlad/planets.git\n* [new branch]      main -&gt; main\n</code></pre> <p>Proxy</p> <p>If the network you are connected to uses a proxy, there is a chance that your last command failed with \"Could not resolve hostname\" as the error message. To solve this issue, you need to tell Git about the proxy:</p> <p>code</p> <pre><code>$ git config --global http.proxy http://user:password@proxy.url\n$ git config --global https.proxy https://user:password@proxy.url\n</code></pre> <p>When you connect to another network that doesn't use a proxy, you will need to tell Git to disable the proxy using:</p> <p>code</p> <pre><code>$ git config --global --unset http.proxy\n$ git config --global --unset https.proxy\n</code></pre> <p>Password Managers</p> <p>If your operating system has a password manager configured, <code>git push</code> will try to use it when it needs your username and password. For example, this is the default behavior for Git Bash on Windows. If you want to type your username and password at the terminal instead of using a password manager, type:</p> <p>code</p> <pre><code>$ unset SSH_ASKPASS\n</code></pre> <p>in the terminal, before you run <code>git push</code>. Despite the name, Git uses <code>SSH_ASKPASS</code> for all credential entry, so you may want to unset <code>SSH_ASKPASS</code> whether you are using Git via SSH or https.</p> <p>You may also want to add <code>unset SSH_ASKPASS</code> at the end of your <code>~/.bashrc</code> to make Git default to using the terminal for usernames and passwords.</p> <p>Our local and remote repositories are now in this state:</p> <p></p> <p>The '-u' Flag</p> <p>You may see a <code>-u</code> option used with <code>git push</code> in some documentation. This option is synonymous with the <code>--set-upstream-to</code> option for the <code>git branch</code> command, and is used to associate the current branch with a remote branch so that the <code>git pull</code> command can be used without any arguments. To do this, simply use <code>git push -u origin main</code> once the remote has been set up.</p> <p>We can pull changes from the remote repository to the local one as well:</p> <p>code</p> <pre><code>$ git pull origin main\n</code></pre> <pre><code>From https://github.com/vlad/vc_project\n* branch            main     -&gt; FETCH_HEAD\nAlready up-to-date.\n</code></pre> <p>Pulling has no effect in this case because the two repositories are already synchronized. If someone else had pushed some changes to the repository on GitHub, though, this command would download them to our local repository.</p> <p>GitHub GUI</p> <p>Browse to your <code>vc_project</code> repository on GitHub. Underneath the Code button, find and click on the text that says \"XX commits\" (where \"XX\" is some number). Hover over, and click on, the three buttons to the right of each commit. What information can you gather/explore from these buttons? How would you get that same information in the shell?</p> Solution <p>The left-most button (with the picture of a clipboard) copies the full identifier of the commit to the clipboard. In the shell, <code>git log</code> will show you the full commit identifier for each commit.</p> <p>When you click on the middle button, you'll see all of the changes that were made in that particular commit. Green shaded lines indicate additions and red ones removals. In the shell we can do the same thing with <code>git diff</code>. In particular, <code>git diff ID1..ID2</code> where ID1 and ID2 are commit identifiers (e.g. <code>git diff a3bf1e5..041e637</code>) will show the differences between those two commits.</p> <p>The right-most button lets you view all of the files in the repository at the time of that commit. To do this in the shell, we'd need to checkout the repository at that particular time. We can do this with <code>git checkout ID</code> where ID is the identifier of the commit we want to look at. If we do this, we need to remember to put the repository back to the right state afterwards!</p> <p>Uploading files directly in GitHub browser</p> <p>Github also allows you to skip the command line and upload files directly to your repository without having to leave the browser. There are two options. First you can click the \"Upload files\" button in the toolbar at the top of the file tree. Or, you can drag and drop files from your desktop onto the file tree. You can read more about this on this GitHub page.</p> <p>GitHub Timestamp</p> <p>Create a remote repository on GitHub. Push the contents of your local repository to the remote. Make changes to your local repository and push these changes. Go to the repo you just created on GitHub and check the timestamps of the files. How does GitHub record times, and why?</p> Solution <p>GitHub displays timestamps in a human readable relative format (i.e. \"22 hours ago\" or \"three weeks ago\"). However, if you hover over the timestamp, you can see the exact time at which the last change to the file occurred.</p> <p>Push vs. Commit</p> <p>In this episode, we introduced the \"git push\" command. How is \"git push\" different from \"git commit\"?</p> Solution <p>When we push changes, we're interacting with a remote repository to update it with the changes we've made locally (often this corresponds to sharing the changes we've made with others). Commit only updates your local repository.</p> <p>GitHub License and README files</p> <p>In this episode we learned about creating a remote repository on GitHub, but when you initialized your GitHub repo, you didn't add a README.md or a license file. If you had, what do you think would have happened when you tried to link your local and remote repositories?</p> Solution <p>In this case, we'd see a merge conflict due to unrelated histories. When GitHub creates a README.md file, it performs a commit in the remote repository. When you try to pull the remote repository to your local repository, Git detects that they have histories that do not share a common origin and refuses to merge.</p> <p>code</p> <pre><code>$ git pull origin main\n</code></pre> <pre><code>warning: no common commits\nremote: Enumerating objects: 3, done.\nremote: Counting objects: 100% (3/3), done.\nremote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), done.\nFrom https://github.com/vlad/vc_project\n* branch            main     -&gt; FETCH_HEAD\n* [new branch]      main     -&gt; origin/main\nfatal: refusing to merge unrelated histories\n</code></pre> <p>You can force git to merge the two repositories with the option <code>--allow-unrelated-histories</code>. Be careful when you use this option and carefully examine the contents of local and remote repositories before merging.</p> <p>code</p> <pre><code>$ git pull --allow-unrelated-histories origin main\n</code></pre> <pre><code>From https://github.com/vlad/vc_project\n* branch            main     -&gt; FETCH_HEAD\nMerge made by the 'recursive' strategy.\nREADME.md | 1 +\n1 file changed, 1 insertion(+)\ncreate mode 100644 README.md\n</code></pre> <p>Keypoints</p> <ul> <li>A local Git repository can be connected to one or more remote repositories.</li> <li>Use the SSH protocol to connect to remote repositories.</li> <li><code>git push</code> copies changes from a local repository to a remote repository.</li> <li><code>git pull</code> copies changes from a remote repository to a local repository.</li> </ul>"}]}